"""Executive Summary Updater Agent.

This agent is responsible for taking the generated executive summary content
and updating the structured CV with it. It follows the LangGraph pattern
of single responsibility per agent.
"""

from typing import Any, Dict
from pydantic import ValidationError

from src.agents.agent_base import AgentBase
from src.constants.agent_constants import AgentConstants
from src.error_handling.exceptions import AgentExecutionError
from src.models.cv_models import StructuredCV, Item, ItemStatus, ItemType
from src.config.logging_config import get_logger

logger = get_logger(__name__)


class ExecutiveSummaryUpdaterAgent(AgentBase):
    """Agent responsible for updating the structured CV with generated executive summary.
    
    This agent consumes the executive summary content generated by ExecutiveSummaryWriterAgent
    and properly integrates it into the structured CV following the data model patterns.
    """

    def __init__(self, session_id: str, name: str = "ExecutiveSummaryUpdaterAgent"):
        """Initialize the ExecutiveSummaryUpdaterAgent.
        
        Args:
            name: The name of the agent
            session_id: The session identifier
        """
        super().__init__(
            name=name,
            description="Agent responsible for updating the structured CV with generated executive summary",
            session_id=session_id
        )
        logger.info(f"Initialized {self.name}")

    def _validate_inputs(self, kwargs: dict[str, Any]) -> None:
        """Validate required inputs for the agent.
        
        Args:
            kwargs: Input arguments containing structured_cv and generated_executive_summary.
            
        Raises:
            AgentExecutionError: If required inputs are missing or invalid.
        """
        required_fields = ["structured_cv", "generated_executive_summary"]
        for field in required_fields:
            if field not in kwargs or kwargs[field] is None:
                raise AgentExecutionError(self.name, f"Missing required input: {field}")

        # Handle structured_cv input - it may come as a dict from extract_agent_inputs
        structured_cv_value = kwargs["structured_cv"]
        
        # If it's a dict, convert it to StructuredCV
        if isinstance(structured_cv_value, dict):
            try:
                kwargs["structured_cv"] = StructuredCV(**structured_cv_value)
            except Exception as e:
                raise AgentExecutionError(self.name, f"Failed to convert structured_cv dict to StructuredCV: {e}")
        elif not isinstance(kwargs["structured_cv"], StructuredCV):
            raise AgentExecutionError(self.name, f"structured_cv must be a StructuredCV instance, got {type(structured_cv_value)}")
            
        # Validate generated_executive_summary type
        generated_summary = kwargs["generated_executive_summary"]
        if not isinstance(generated_summary, (dict, str)):
            raise AgentExecutionError(self.name, "generated_executive_summary must be a dict or string")
            
        if not generated_summary:
            raise AgentExecutionError(self.name, "generated_executive_summary cannot be empty")

    async def _execute(self, **kwargs: Any) -> dict[str, Any]:
        """Execute the executive summary update logic.
        
        Takes the generated executive summary and updates the structured CV.
        
        Args:
            **kwargs: Must contain 'structured_cv' and 'generated_executive_summary'.
            
        Returns:
            dict containing the updated structured_cv.
        """
        try:
            # Validate inputs
            self._validate_inputs(kwargs)

            structured_cv: StructuredCV = kwargs["structured_cv"]
            generated_summary = kwargs["generated_executive_summary"]

            self.update_progress(
                AgentConstants.PROGRESS_MAIN_PROCESSING, 
                "Updating CV with generated Executive Summary."
            )

            # Find the Executive Summary section
            summary_section = None
            for section in structured_cv.sections:
                if section.name == "Executive Summary":
                    summary_section = section
                    break

            if not summary_section:
                return {
                    "error_messages": [
                        "Executive Summary section not found in structured_cv. It should be pre-initialized."
                    ]
                }

            # Handle different types of generated summary content
            if isinstance(generated_summary, dict):
                # If it's a dict, extract the content
                content = generated_summary.get("summary", generated_summary.get("content", str(generated_summary)))
            else:
                # If it's a string, use it directly
                content = str(generated_summary)

            # Clear existing items and add the new generated content
            summary_section.items.clear()
            
            # Create new item with generated content
            new_item = Item(
                content=content,
                status=ItemStatus.GENERATED,
                item_type=ItemType.EXECUTIVE_SUMMARY_PARA,
            )
            summary_section.items.append(new_item)
            
            current_item_id = kwargs.get("current_item_id", new_item.id)

            logger.info(f"Updated Executive Summary section with generated content")

            self.update_progress(
                AgentConstants.PROGRESS_COMPLETE, 
                "Executive Summary update completed successfully."
            )
            
            return {
                "structured_cv": structured_cv,
                "current_item_id": current_item_id or "executive_summary_section"
            }
            
        except AgentExecutionError as e:
            logger.error(f"Agent execution error in {self.name}: {str(e)}")
            return {"error_messages": [str(e)]}
        except (AttributeError, TypeError, ValueError, KeyError) as e:
            logger.error(f"Error updating Executive Summary: {str(e)}")
            return {"error_messages": [f"Error updating Executive Summary: {str(e)}"]}
        except Exception as e:
            logger.error(f"Unexpected error in {self.name}: {str(e)}", exc_info=True)
            return {"error_messages": [f"Unexpected error during Executive Summary update: {str(e)}"]}